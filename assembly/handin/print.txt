.section .data
integer: .long 112345		# Integer to print

.section .text			
.globl _start
_start:

call aFunction

movl $1,%eax
int $0x80

aFunction:
pushl %ebp				# push 

xorl %esi,%esi			# Zero %esi. %esi = 0
movl integer,%eax		# Move integer value to %eax. %eax = integer
movl $integer, %ecx		# Move integer adress to %ecx. %ecx = (integer)

loop:
xorl %edx,%edx			# Zero %edx. %edx = 0
movl $10,%ebx			#
divl %ebx				# dividing, result in %eax (123) and remainder in %edx (4)
addl $48,%edx			# +48. Convert into ascii
pushl %edx				# on stack
incl %esi				# counter of digits
cmpl $0,%eax			# If eax is zero after division, no more digits	
jz   next				# If zero, then all individual digits are found.
jmp loop				# Otherwise, keep the loop going

next:				#
popl (%ecx)			# Get the value on the stack and overwrite the adress that %ecx is pointing to
testl %esi,%esi		# if(%esi == 0)
jz   functionReturn	#  return()
decl %esi			# Decrease %esi. %esi = %esi - 1
movl $4,%eax		# sys_write
movl $1,%ebx		# Filedescriptor, 1 is standard out
movl $2,%edx		# 
int  $0x80			# System Call 
jmp  next
functionReturn:

movl $0, %eax
ret


